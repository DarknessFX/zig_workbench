// THIS FILE HAS BEEN AUTO-GENERATED BY THE 'DEAR BINDINGS' GENERATOR.
// **DO NOT EDIT DIRECTLY**
// https://github.com/dearimgui/dear_bindings

// THIS FILE HAS BEEN AUTO-GENERATED BY THE 'DEAR BINDINGS' GENERATOR.
// **DO NOT EDIT DIRECTLY**
// https://github.com/dearimgui/dear_bindings

// MIT License

// Copyright (c) 2023 Evan Pezent

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// ImPlot v0.17

// Table of Contents:
//
// [SECTION] Macros and Defines
// [SECTION] Enums and Types
// [SECTION] Callbacks
// [SECTION] Contexts
// [SECTION] Begin/End Plot
// [SECTION] Begin/End Subplot
// [SECTION] Setup
// [SECTION] SetNext
// [SECTION] Plot Items
// [SECTION] Plot Tools
// [SECTION] Plot Utils
// [SECTION] Legend Utils
// [SECTION] Drag and Drop
// [SECTION] Styling
// [SECTION] Colormaps
// [SECTION] Input Mapping
// [SECTION] Miscellaneous
// [SECTION] Demo
// [SECTION] Obsolete API

#pragma once

#ifdef __cplusplus
extern "C"
{
#endif
#include "cimgui.h"

//-----------------------------------------------------------------------------
// [SECTION] Macros and Defines
//-----------------------------------------------------------------------------

// Define attributes of all API symbols declarations (e.g. for DLL under Windows)
// Using ImPlot via a shared library is not recommended, because we don't guarantee
// backward nor forward ABI compatibility and also function call overhead. If you
// do use ImPlot as a DLL, be sure to call SetImGuiContext (see Miscellanous section).
#ifndef IMPLOT_API
#define IMPLOT_API
#endif // #ifndef IMPLOT_API
// ImPlot version string.
#define IMPLOT_VERSION "0.17"
// Indicates variable should deduced automatically.
#define IMPLOT_AUTO -1
// Special color used to indicate that a color should be deduced automatically.
#define IMPLOT_AUTO_COL ImVec4(0,0,0,-1)
// Macro for templated plotting functions; keeps header clean.
#define IMPLOT_TMP template <typename T> IMPLOT_API

//-----------------------------------------------------------------------------
// [SECTION] Enums and Types
//-----------------------------------------------------------------------------

// Forward declarations
typedef struct ImPlotContext_t ImPlotContext;  // ImPlot context (opaque struct, see implot_internal.h)

// Enums/Flags
typedef int ImAxis;                    // -> enum ImAxis_
typedef int ImPlotFlags;               // -> enum ImPlotFlags_
typedef int ImPlotAxisFlags;           // -> enum ImPlotAxisFlags_
typedef int ImPlotSubplotFlags;        // -> enum ImPlotSubplotFlags_
typedef int ImPlotLegendFlags;         // -> enum ImPlotLegendFlags_
typedef int ImPlotMouseTextFlags;      // -> enum ImPlotMouseTextFlags_
typedef int ImPlotDragToolFlags;       // -> ImPlotDragToolFlags_
typedef int ImPlotColormapScaleFlags;  // -> ImPlotColormapScaleFlags_

typedef int ImPlotItemFlags;       // -> ImPlotItemFlags_
typedef int ImPlotLineFlags;       // -> ImPlotLineFlags_
typedef int ImPlotScatterFlags;    // -> ImPlotScatterFlags
typedef int ImPlotStairsFlags;     // -> ImPlotStairsFlags_
typedef int ImPlotShadedFlags;     // -> ImPlotShadedFlags_
typedef int ImPlotBarsFlags;       // -> ImPlotBarsFlags_
typedef int ImPlotBarGroupsFlags;  // -> ImPlotBarGroupsFlags_
typedef int ImPlotErrorBarsFlags;  // -> ImPlotErrorBarsFlags_
typedef int ImPlotStemsFlags;      // -> ImPlotStemsFlags_
typedef int ImPlotInfLinesFlags;   // -> ImPlotInfLinesFlags_
typedef int ImPlotPieChartFlags;   // -> ImPlotPieChartFlags_
typedef int ImPlotHeatmapFlags;    // -> ImPlotHeatmapFlags_
typedef int ImPlotHistogramFlags;  // -> ImPlotHistogramFlags_
typedef int ImPlotDigitalFlags;    // -> ImPlotDigitalFlags_
typedef int ImPlotImageFlags;      // -> ImPlotImageFlags_
typedef int ImPlotTextFlags;       // -> ImPlotTextFlags_
typedef int ImPlotDummyFlags;      // -> ImPlotDummyFlags_

typedef int ImPlotCond;      // -> enum ImPlotCond_
typedef int ImPlotCol;       // -> enum ImPlotCol_
typedef int ImPlotStyleVar;  // -> enum ImPlotStyleVar_
typedef int ImPlotScale;     // -> enum ImPlotScale_
typedef int ImPlotMarker;    // -> enum ImPlotMarker_
typedef int ImPlotColormap;  // -> enum ImPlotColormap_
typedef int ImPlotLocation;  // -> enum ImPlotLocation_
typedef int ImPlotBin;       // -> enum ImPlotBin_

// Axis indices. The values assigned may change; NEVER hardcode these.
typedef enum
{
    // horizontal axes
    ImAxis_X1    = 0,  // enabled by default
    ImAxis_X2,         // disabled by default
    ImAxis_X3,         // disabled by default
    // vertical axes
    ImAxis_Y1,         // enabled by default
    ImAxis_Y2,         // disabled by default
    ImAxis_Y3,         // disabled by default
    // bookeeping
    ImAxis_COUNT,
} ImAxis_;

// Options for plots (see BeginPlot).
typedef enum
{
    ImPlotFlags_None        = 0,     // default
    ImPlotFlags_NoTitle     = 1<<0,  // the plot title will not be displayed (titles are also hidden if preceeded by double hashes, e.g. "##MyPlot")
    ImPlotFlags_NoLegend    = 1<<1,  // the legend will not be displayed
    ImPlotFlags_NoMouseText = 1<<2,  // the mouse position, in plot coordinates, will not be displayed inside of the plot
    ImPlotFlags_NoInputs    = 1<<3,  // the user will not be able to interact with the plot
    ImPlotFlags_NoMenus     = 1<<4,  // the user will not be able to open context menus
    ImPlotFlags_NoBoxSelect = 1<<5,  // the user will not be able to box-select
    ImPlotFlags_NoFrame     = 1<<6,  // the ImGui frame will not be rendered
    ImPlotFlags_Equal       = 1<<7,  // x and y axes pairs will be constrained to have the same units/pixel
    ImPlotFlags_Crosshairs  = 1<<8,  // the default mouse cursor will be replaced with a crosshair when hovered
    ImPlotFlags_CanvasOnly  = ImPlotFlags_NoTitle | ImPlotFlags_NoLegend | ImPlotFlags_NoMenus | ImPlotFlags_NoBoxSelect | ImPlotFlags_NoMouseText,
} ImPlotFlags_;

// Options for plot axes (see SetupAxis).
typedef enum
{
    ImPlotAxisFlags_None          = 0,      // default
    ImPlotAxisFlags_NoLabel       = 1<<0,   // the axis label will not be displayed (axis labels are also hidden if the supplied string name is nullptr)
    ImPlotAxisFlags_NoGridLines   = 1<<1,   // no grid lines will be displayed
    ImPlotAxisFlags_NoTickMarks   = 1<<2,   // no tick marks will be displayed
    ImPlotAxisFlags_NoTickLabels  = 1<<3,   // no text labels will be displayed
    ImPlotAxisFlags_NoInitialFit  = 1<<4,   // axis will not be initially fit to data extents on the first rendered frame
    ImPlotAxisFlags_NoMenus       = 1<<5,   // the user will not be able to open context menus with right-click
    ImPlotAxisFlags_NoSideSwitch  = 1<<6,   // the user will not be able to switch the axis side by dragging it
    ImPlotAxisFlags_NoHighlight   = 1<<7,   // the axis will not have its background highlighted when hovered or held
    ImPlotAxisFlags_Opposite      = 1<<8,   // axis ticks and labels will be rendered on the conventionally opposite side (i.e, right or top)
    ImPlotAxisFlags_Foreground    = 1<<9,   // grid lines will be displayed in the foreground (i.e. on top of data) instead of the background
    ImPlotAxisFlags_Invert        = 1<<10,  // the axis will be inverted
    ImPlotAxisFlags_AutoFit       = 1<<11,  // axis will be auto-fitting to data extents
    ImPlotAxisFlags_RangeFit      = 1<<12,  // axis will only fit points if the point is in the visible range of the **orthogonal** axis
    ImPlotAxisFlags_PanStretch    = 1<<13,  // panning in a locked or constrained state will cause the axis to stretch if possible
    ImPlotAxisFlags_LockMin       = 1<<14,  // the axis minimum value will be locked when panning/zooming
    ImPlotAxisFlags_LockMax       = 1<<15,  // the axis maximum value will be locked when panning/zooming
    ImPlotAxisFlags_Lock          = ImPlotAxisFlags_LockMin | ImPlotAxisFlags_LockMax,
    ImPlotAxisFlags_NoDecorations = ImPlotAxisFlags_NoLabel | ImPlotAxisFlags_NoGridLines | ImPlotAxisFlags_NoTickMarks | ImPlotAxisFlags_NoTickLabels,
    ImPlotAxisFlags_AuxDefault    = ImPlotAxisFlags_NoGridLines | ImPlotAxisFlags_Opposite,
} ImPlotAxisFlags_;

// Options for subplots (see BeginSubplot)
typedef enum
{
    ImPlotSubplotFlags_None       = 0,      // default
    ImPlotSubplotFlags_NoTitle    = 1<<0,   // the subplot title will not be displayed (titles are also hidden if preceeded by double hashes, e.g. "##MySubplot")
    ImPlotSubplotFlags_NoLegend   = 1<<1,   // the legend will not be displayed (only applicable if ImPlotSubplotFlags_ShareItems is enabled)
    ImPlotSubplotFlags_NoMenus    = 1<<2,   // the user will not be able to open context menus with right-click
    ImPlotSubplotFlags_NoResize   = 1<<3,   // resize splitters between subplot cells will be not be provided
    ImPlotSubplotFlags_NoAlign    = 1<<4,   // subplot edges will not be aligned vertically or horizontally
    ImPlotSubplotFlags_ShareItems = 1<<5,   // items across all subplots will be shared and rendered into a single legend entry
    ImPlotSubplotFlags_LinkRows   = 1<<6,   // link the y-axis limits of all plots in each row (does not apply to auxiliary axes)
    ImPlotSubplotFlags_LinkCols   = 1<<7,   // link the x-axis limits of all plots in each column (does not apply to auxiliary axes)
    ImPlotSubplotFlags_LinkAllX   = 1<<8,   // link the x-axis limits in every plot in the subplot (does not apply to auxiliary axes)
    ImPlotSubplotFlags_LinkAllY   = 1<<9,   // link the y-axis limits in every plot in the subplot (does not apply to auxiliary axes)
    ImPlotSubplotFlags_ColMajor   = 1<<10,  // subplots are added in column major order instead of the default row major order
} ImPlotSubplotFlags_;

// Options for legends (see SetupLegend)
typedef enum
{
    ImPlotLegendFlags_None            = 0,     // default
    ImPlotLegendFlags_NoButtons       = 1<<0,  // legend icons will not function as hide/show buttons
    ImPlotLegendFlags_NoHighlightItem = 1<<1,  // plot items will not be highlighted when their legend entry is hovered
    ImPlotLegendFlags_NoHighlightAxis = 1<<2,  // axes will not be highlighted when legend entries are hovered (only relevant if x/y-axis count > 1)
    ImPlotLegendFlags_NoMenus         = 1<<3,  // the user will not be able to open context menus with right-click
    ImPlotLegendFlags_Outside         = 1<<4,  // legend will be rendered outside of the plot area
    ImPlotLegendFlags_Horizontal      = 1<<5,  // legend entries will be displayed horizontally
    ImPlotLegendFlags_Sort            = 1<<6,  // legend entries will be displayed in alphabetical order
} ImPlotLegendFlags_;

// Options for mouse hover text (see SetupMouseText)
typedef enum
{
    ImPlotMouseTextFlags_None       = 0,     // default
    ImPlotMouseTextFlags_NoAuxAxes  = 1<<0,  // only show the mouse position for primary axes
    ImPlotMouseTextFlags_NoFormat   = 1<<1,  // axes label formatters won't be used to render text
    ImPlotMouseTextFlags_ShowAlways = 1<<2,  // always display mouse position even if plot not hovered
} ImPlotMouseTextFlags_;

// Options for DragPoint, DragLine, DragRect
typedef enum
{
    ImPlotDragToolFlags_None      = 0,     // default
    ImPlotDragToolFlags_NoCursors = 1<<0,  // drag tools won't change cursor icons when hovered or held
    ImPlotDragToolFlags_NoFit     = 1<<1,  // the drag tool won't be considered for plot fits
    ImPlotDragToolFlags_NoInputs  = 1<<2,  // lock the tool from user inputs
    ImPlotDragToolFlags_Delayed   = 1<<3,  // tool rendering will be delayed one frame; useful when applying position-constraints
} ImPlotDragToolFlags_;

// Flags for ColormapScale
typedef enum
{
    ImPlotColormapScaleFlags_None     = 0,     // default
    ImPlotColormapScaleFlags_NoLabel  = 1<<0,  // the colormap axis label will not be displayed
    ImPlotColormapScaleFlags_Opposite = 1<<1,  // render the colormap label and tick labels on the opposite side
    ImPlotColormapScaleFlags_Invert   = 1<<2,  // invert the colormap bar and axis scale (this only affects rendering; if you only want to reverse the scale mapping, make scale_min > scale_max)
} ImPlotColormapScaleFlags_;

// Flags for ANY PlotX function
typedef enum
{
    ImPlotItemFlags_None     = 0,
    ImPlotItemFlags_NoLegend = 1<<0,  // the item won't have a legend entry displayed
    ImPlotItemFlags_NoFit    = 1<<1,  // the item won't be considered for plot fits
} ImPlotItemFlags_;

// Flags for PlotLine
typedef enum
{
    ImPlotLineFlags_None     = 0,      // default
    ImPlotLineFlags_Segments = 1<<10,  // a line segment will be rendered from every two consecutive points
    ImPlotLineFlags_Loop     = 1<<11,  // the last and first point will be connected to form a closed loop
    ImPlotLineFlags_SkipNaN  = 1<<12,  // NaNs values will be skipped instead of rendered as missing data
    ImPlotLineFlags_NoClip   = 1<<13,  // markers (if displayed) on the edge of a plot will not be clipped
    ImPlotLineFlags_Shaded   = 1<<14,  // a filled region between the line and horizontal origin will be rendered; use PlotShaded for more advanced cases
} ImPlotLineFlags_;

// Flags for PlotScatter
typedef enum
{
    ImPlotScatterFlags_None   = 0,      // default
    ImPlotScatterFlags_NoClip = 1<<10,  // markers on the edge of a plot will not be clipped
} ImPlotScatterFlags_;

// Flags for PlotStairs
typedef enum
{
    ImPlotStairsFlags_None    = 0,      // default
    ImPlotStairsFlags_PreStep = 1<<10,  // the y value is continued constantly to the left from every x position, i.e. the interval (x[i-1], x[i]] has the value y[i]
    ImPlotStairsFlags_Shaded  = 1<<11,  // a filled region between the stairs and horizontal origin will be rendered; use PlotShaded for more advanced cases
} ImPlotStairsFlags_;

// Flags for PlotShaded (placeholder)
typedef enum
{
    ImPlotShadedFlags_None = 0,  // default
} ImPlotShadedFlags_;

// Flags for PlotBars
typedef enum
{
    ImPlotBarsFlags_None       = 0,      // default
    ImPlotBarsFlags_Horizontal = 1<<10,  // bars will be rendered horizontally on the current y-axis
} ImPlotBarsFlags_;

// Flags for PlotBarGroups
typedef enum
{
    ImPlotBarGroupsFlags_None       = 0,      // default
    ImPlotBarGroupsFlags_Horizontal = 1<<10,  // bar groups will be rendered horizontally on the current y-axis
    ImPlotBarGroupsFlags_Stacked    = 1<<11,  // items in a group will be stacked on top of each other
} ImPlotBarGroupsFlags_;

// Flags for PlotErrorBars
typedef enum
{
    ImPlotErrorBarsFlags_None       = 0,      // default
    ImPlotErrorBarsFlags_Horizontal = 1<<10,  // error bars will be rendered horizontally on the current y-axis
} ImPlotErrorBarsFlags_;

// Flags for PlotStems
typedef enum
{
    ImPlotStemsFlags_None       = 0,      // default
    ImPlotStemsFlags_Horizontal = 1<<10,  // stems will be rendered horizontally on the current y-axis
} ImPlotStemsFlags_;

// Flags for PlotInfLines
typedef enum
{
    ImPlotInfLinesFlags_None       = 0,      // default
    ImPlotInfLinesFlags_Horizontal = 1<<10,  // lines will be rendered horizontally on the current y-axis
} ImPlotInfLinesFlags_;

// Flags for PlotPieChart
typedef enum
{
    ImPlotPieChartFlags_None         = 0,      // default
    ImPlotPieChartFlags_Normalize    = 1<<10,  // force normalization of pie chart values (i.e. always make a full circle if sum < 0)
    ImPlotPieChartFlags_IgnoreHidden = 1<<11,  // ignore hidden slices when drawing the pie chart (as if they were not there)
} ImPlotPieChartFlags_;

// Flags for PlotHeatmap
typedef enum
{
    ImPlotHeatmapFlags_None     = 0,      // default
    ImPlotHeatmapFlags_ColMajor = 1<<10,  // data will be read in column major order
} ImPlotHeatmapFlags_;

// Flags for PlotHistogram and PlotHistogram2D
typedef enum
{
    ImPlotHistogramFlags_None       = 0,      // default
    ImPlotHistogramFlags_Horizontal = 1<<10,  // histogram bars will be rendered horizontally (not supported by PlotHistogram2D)
    ImPlotHistogramFlags_Cumulative = 1<<11,  // each bin will contain its count plus the counts of all previous bins (not supported by PlotHistogram2D)
    ImPlotHistogramFlags_Density    = 1<<12,  // counts will be normalized, i.e. the PDF will be visualized, or the CDF will be visualized if Cumulative is also set
    ImPlotHistogramFlags_NoOutliers = 1<<13,  // exclude values outside the specifed histogram range from the count toward normalizing and cumulative counts
    ImPlotHistogramFlags_ColMajor   = 1<<14,  // data will be read in column major order (not supported by PlotHistogram)
} ImPlotHistogramFlags_;

// Flags for PlotDigital (placeholder)
typedef enum
{
    ImPlotDigitalFlags_None = 0,  // default
} ImPlotDigitalFlags_;

// Flags for PlotImage (placeholder)
typedef enum
{
    ImPlotImageFlags_None = 0,  // default
} ImPlotImageFlags_;

// Flags for PlotText
typedef enum
{
    ImPlotTextFlags_None     = 0,      // default
    ImPlotTextFlags_Vertical = 1<<10,  // text will be rendered vertically
} ImPlotTextFlags_;

// Flags for PlotDummy (placeholder)
typedef enum
{
    ImPlotDummyFlags_None = 0,  // default
} ImPlotDummyFlags_;

// Represents a condition for SetupAxisLimits etc. (same as ImGuiCond, but we only support a subset of those enums)
typedef enum
{
    ImPlotCond_None   = 0,     // No condition (always set the variable), same as _Always
    ImPlotCond_Always = 1<<0,  // No condition (always set the variable)
    ImPlotCond_Once   = 1<<1,  // Set the variable once per runtime session (only the first call will succeed)
} ImPlotCond_;

// Plot styling colors.
typedef enum
{
    // item styling colors
    ImPlotCol_Line,           // plot line/outline color (defaults to next unused color in current colormap)
    ImPlotCol_Fill,           // plot fill color for bars (defaults to the current line color)
    ImPlotCol_MarkerOutline,  // marker outline color (defaults to the current line color)
    ImPlotCol_MarkerFill,     // marker fill color (defaults to the current line color)
    ImPlotCol_ErrorBar,       // error bar color (defaults to ImGuiCol_Text)
    // plot styling colors
    ImPlotCol_FrameBg,        // plot frame background color (defaults to ImGuiCol_FrameBg)
    ImPlotCol_PlotBg,         // plot area background color (defaults to ImGuiCol_WindowBg)
    ImPlotCol_PlotBorder,     // plot area border color (defaults to ImGuiCol_Border)
    ImPlotCol_LegendBg,       // legend background color (defaults to ImGuiCol_PopupBg)
    ImPlotCol_LegendBorder,   // legend border color (defaults to ImPlotCol_PlotBorder)
    ImPlotCol_LegendText,     // legend text color (defaults to ImPlotCol_InlayText)
    ImPlotCol_TitleText,      // plot title text color (defaults to ImGuiCol_Text)
    ImPlotCol_InlayText,      // color of text appearing inside of plots (defaults to ImGuiCol_Text)
    ImPlotCol_AxisText,       // axis label and tick lables color (defaults to ImGuiCol_Text)
    ImPlotCol_AxisGrid,       // axis grid color (defaults to 25% ImPlotCol_AxisText)
    ImPlotCol_AxisTick,       // axis tick color (defaults to AxisGrid)
    ImPlotCol_AxisBg,         // background color of axis hover region (defaults to transparent)
    ImPlotCol_AxisBgHovered,  // axis hover color (defaults to ImGuiCol_ButtonHovered)
    ImPlotCol_AxisBgActive,   // axis active color (defaults to ImGuiCol_ButtonActive)
    ImPlotCol_Selection,      // box-selection color (defaults to yellow)
    ImPlotCol_Crosshairs,     // crosshairs color (defaults to ImPlotCol_PlotBorder)
    ImPlotCol_COUNT,
} ImPlotCol_;

// Plot styling variables.
typedef enum
{
    // item styling variables
    ImPlotStyleVar_LineWeight,          // float,  plot item line weight in pixels
    ImPlotStyleVar_Marker,              // int,    marker specification
    ImPlotStyleVar_MarkerSize,          // float,  marker size in pixels (roughly the marker's "radius")
    ImPlotStyleVar_MarkerWeight,        // float,  plot outline weight of markers in pixels
    ImPlotStyleVar_FillAlpha,           // float,  alpha modifier applied to all plot item fills
    ImPlotStyleVar_ErrorBarSize,        // float,  error bar whisker width in pixels
    ImPlotStyleVar_ErrorBarWeight,      // float,  error bar whisker weight in pixels
    ImPlotStyleVar_DigitalBitHeight,    // float,  digital channels bit height (at 1) in pixels
    ImPlotStyleVar_DigitalBitGap,       // float,  digital channels bit padding gap in pixels
    // plot styling variables
    ImPlotStyleVar_PlotBorderSize,      // float,  thickness of border around plot area
    ImPlotStyleVar_MinorAlpha,          // float,  alpha multiplier applied to minor axis grid lines
    ImPlotStyleVar_MajorTickLen,        // ImVec2, major tick lengths for X and Y axes
    ImPlotStyleVar_MinorTickLen,        // ImVec2, minor tick lengths for X and Y axes
    ImPlotStyleVar_MajorTickSize,       // ImVec2, line thickness of major ticks
    ImPlotStyleVar_MinorTickSize,       // ImVec2, line thickness of minor ticks
    ImPlotStyleVar_MajorGridSize,       // ImVec2, line thickness of major grid lines
    ImPlotStyleVar_MinorGridSize,       // ImVec2, line thickness of minor grid lines
    ImPlotStyleVar_PlotPadding,         // ImVec2, padding between widget frame and plot area, labels, or outside legends (i.e. main padding)
    ImPlotStyleVar_LabelPadding,        // ImVec2, padding between axes labels, tick labels, and plot edge
    ImPlotStyleVar_LegendPadding,       // ImVec2, legend padding from plot edges
    ImPlotStyleVar_LegendInnerPadding,  // ImVec2, legend inner padding from legend edges
    ImPlotStyleVar_LegendSpacing,       // ImVec2, spacing between legend entries
    ImPlotStyleVar_MousePosPadding,     // ImVec2, padding between plot edge and interior info text
    ImPlotStyleVar_AnnotationPadding,   // ImVec2, text padding around annotation labels
    ImPlotStyleVar_FitPadding,          // ImVec2, additional fit padding as a percentage of the fit extents (e.g. ImVec2(0.1f,0.1f) adds 10% to the fit extents of X and Y)
    ImPlotStyleVar_PlotDefaultSize,     // ImVec2, default size used when ImVec2(0,0) is passed to BeginPlot
    ImPlotStyleVar_PlotMinSize,         // ImVec2, minimum size plot frame can be when shrunk
    ImPlotStyleVar_COUNT,
} ImPlotStyleVar_;

// Axis scale
typedef enum
{
    ImPlotScale_Linear = 0,  // default linear scale
    ImPlotScale_Time,        // date/time scale
    ImPlotScale_Log10,       // base 10 logartithmic scale
    ImPlotScale_SymLog,      // symmetric log scale
} ImPlotScale_;

// Marker specifications.
typedef enum
{
    ImPlotMarker_None     = -1,  // no marker
    ImPlotMarker_Circle,         // a circle marker (default)
    ImPlotMarker_Square,         // a square maker
    ImPlotMarker_Diamond,        // a diamond marker
    ImPlotMarker_Up,             // an upward-pointing triangle marker
    ImPlotMarker_Down,           // an downward-pointing triangle marker
    ImPlotMarker_Left,           // an leftward-pointing triangle marker
    ImPlotMarker_Right,          // an rightward-pointing triangle marker
    ImPlotMarker_Cross,          // a cross marker (not fillable)
    ImPlotMarker_Plus,           // a plus marker (not fillable)
    ImPlotMarker_Asterisk,       // a asterisk marker (not fillable)
    ImPlotMarker_COUNT,
} ImPlotMarker_;

// Built-in colormaps
typedef enum
{
    ImPlotColormap_Deep     = 0,   // a.k.a. seaborn deep             (qual=true,  n=10) (default)
    ImPlotColormap_Dark     = 1,   // a.k.a. matplotlib "Set1"        (qual=true,  n=9 )
    ImPlotColormap_Pastel   = 2,   // a.k.a. matplotlib "Pastel1"     (qual=true,  n=9 )
    ImPlotColormap_Paired   = 3,   // a.k.a. matplotlib "Paired"      (qual=true,  n=12)
    ImPlotColormap_Viridis  = 4,   // a.k.a. matplotlib "viridis"     (qual=false, n=11)
    ImPlotColormap_Plasma   = 5,   // a.k.a. matplotlib "plasma"      (qual=false, n=11)
    ImPlotColormap_Hot      = 6,   // a.k.a. matplotlib/MATLAB "hot"  (qual=false, n=11)
    ImPlotColormap_Cool     = 7,   // a.k.a. matplotlib/MATLAB "cool" (qual=false, n=11)
    ImPlotColormap_Pink     = 8,   // a.k.a. matplotlib/MATLAB "pink" (qual=false, n=11)
    ImPlotColormap_Jet      = 9,   // a.k.a. MATLAB "jet"             (qual=false, n=11)
    ImPlotColormap_Twilight = 10,  // a.k.a. matplotlib "twilight"    (qual=false, n=11)
    ImPlotColormap_RdBu     = 11,  // red/blue, Color Brewer          (qual=false, n=11)
    ImPlotColormap_BrBG     = 12,  // brown/blue-green, Color Brewer  (qual=false, n=11)
    ImPlotColormap_PiYG     = 13,  // pink/yellow-green, Color Brewer (qual=false, n=11)
    ImPlotColormap_Spectral = 14,  // color spectrum, Color Brewer    (qual=false, n=11)
    ImPlotColormap_Greys    = 15,  // white/black                     (qual=false, n=2 )
} ImPlotColormap_;

// Used to position items on a plot (e.g. legends, labels, etc.)
typedef enum
{
    ImPlotLocation_Center    = 0,                                           // center-center
    ImPlotLocation_North     = 1<<0,                                        // top-center
    ImPlotLocation_South     = 1<<1,                                        // bottom-center
    ImPlotLocation_West      = 1<<2,                                        // center-left
    ImPlotLocation_East      = 1<<3,                                        // center-right
    ImPlotLocation_NorthWest = ImPlotLocation_North | ImPlotLocation_West,  // top-left
    ImPlotLocation_NorthEast = ImPlotLocation_North | ImPlotLocation_East,  // top-right
    ImPlotLocation_SouthWest = ImPlotLocation_South | ImPlotLocation_West,  // bottom-left
    ImPlotLocation_SouthEast = ImPlotLocation_South | ImPlotLocation_East,  // bottom-right
} ImPlotLocation_;

// Enums for different automatic histogram binning methods (k = bin count or w = bin width)
typedef enum
{
    ImPlotBin_Sqrt    = -1,  // k = sqrt(n)
    ImPlotBin_Sturges = -2,  // k = 1 + log2(n)
    ImPlotBin_Rice    = -3,  // k = 2 * cbrt(n)
    ImPlotBin_Scott   = -4,  // w = 3.49 * sigma / cbrt(n)
} ImPlotBin_;

// Double precision version of ImVec2 used by ImPlot. Extensible by end users.
IM_MSVC_RUNTIME_CHECKS_OFF
typedef struct ImPlotPoint_t
{
    double x, y;
#ifdef IMPLOT_POINT_CLASS_EXTRA
    IMPLOT_POINT_CLASS_EXTRA  // Define additional constructors and implicit cast operators in imconfig.h
    // to convert back and forth between your math types and ImPlotPoint.
#endif // #ifdef IMPLOT_POINT_CLASS_EXTRA
} ImPlotPoint;
IM_MSVC_RUNTIME_CHECKS_RESTORE

// Range defined by a min/max value.
typedef struct ImPlotRange_t
{
    double Min, Max;
} ImPlotRange;
CIMGUI_API bool   ImPlotRange_Contains(const ImPlotRange* self, double value);
CIMGUI_API double ImPlotRange_Size(const ImPlotRange* self);
CIMGUI_API double ImPlotRange_Clamp(const ImPlotRange* self, double value);

// Combination of two range limits for X and Y axes. Also an AABB defined by Min()/Max().
typedef struct ImPlotRect_t
{
    ImPlotRange X, Y;
} ImPlotRect;
CIMGUI_API bool        ImPlotRect_Contains(const ImPlotRect* self, ImPlotPoint p);
CIMGUI_API bool        ImPlotRect_ContainsDouble(const ImPlotRect* self, double x, double y);
CIMGUI_API ImPlotPoint ImPlotRect_Size(const ImPlotRect* self);
CIMGUI_API ImPlotPoint ImPlotRect_Clamp(ImPlotRect* self, ImPlotPoint p);
CIMGUI_API ImPlotPoint ImPlotRect_ClampDouble(ImPlotRect* self, double x, double y);
CIMGUI_API ImPlotPoint ImPlotRect_Min(const ImPlotRect* self);
CIMGUI_API ImPlotPoint ImPlotRect_Max(const ImPlotRect* self);

// Plot style structure
typedef struct ImPlotStyle_t
{
    // item styling variables
    float          LineWeight;               // = 1,      item line weight in pixels
    int            Marker;                   // = ImPlotMarker_None, marker specification
    float          MarkerSize;               // = 4,      marker size in pixels (roughly the marker's "radius")
    float          MarkerWeight;             // = 1,      outline weight of markers in pixels
    float          FillAlpha;                // = 1,      alpha modifier applied to plot fills
    float          ErrorBarSize;             // = 5,      error bar whisker width in pixels
    float          ErrorBarWeight;           // = 1.5,    error bar whisker weight in pixels
    float          DigitalBitHeight;         // = 8,      digital channels bit height (at y = 1.0f) in pixels
    float          DigitalBitGap;            // = 4,      digital channels bit padding gap in pixels
    // plot styling variables
    float          PlotBorderSize;           // = 1,      line thickness of border around plot area
    float          MinorAlpha;               // = 0.25    alpha multiplier applied to minor axis grid lines
    ImVec2         MajorTickLen;             // = 10,10   major tick lengths for X and Y axes
    ImVec2         MinorTickLen;             // = 5,5     minor tick lengths for X and Y axes
    ImVec2         MajorTickSize;            // = 1,1     line thickness of major ticks
    ImVec2         MinorTickSize;            // = 1,1     line thickness of minor ticks
    ImVec2         MajorGridSize;            // = 1,1     line thickness of major grid lines
    ImVec2         MinorGridSize;            // = 1,1     line thickness of minor grid lines
    ImVec2         PlotPadding;              // = 10,10   padding between widget frame and plot area, labels, or outside legends (i.e. main padding)
    ImVec2         LabelPadding;             // = 5,5     padding between axes labels, tick labels, and plot edge
    ImVec2         LegendPadding;            // = 10,10   legend padding from plot edges
    ImVec2         LegendInnerPadding;       // = 5,5     legend inner padding from legend edges
    ImVec2         LegendSpacing;            // = 5,0     spacing between legend entries
    ImVec2         MousePosPadding;          // = 10,10   padding between plot edge and interior mouse location text
    ImVec2         AnnotationPadding;        // = 2,2     text padding around annotation labels
    ImVec2         FitPadding;               // = 0,0     additional fit padding as a percentage of the fit extents (e.g. ImVec2(0.1f,0.1f) adds 10% to the fit extents of X and Y)
    ImVec2         PlotDefaultSize;          // = 400,300 default size used when ImVec2(0,0) is passed to BeginPlot
    ImVec2         PlotMinSize;              // = 200,150 minimum size plot frame can be when shrunk
    // style colors
    ImVec4         Colors[ImPlotCol_COUNT];  // Array of styling colors. Indexable with ImPlotCol_ enums.
    // colormap
    ImPlotColormap Colormap;                 // The current colormap. Set this to either an ImPlotColormap_ enum or an index returned by AddColormap.
    // settings/flags
    bool           UseLocalTime;             // = false,  axis labels will be formatted for your timezone when ImPlotAxisFlag_Time is enabled
    bool           UseISO8601;               // = false,  dates will be formatted according to ISO 8601 where applicable (e.g. YYYY-MM-DD, YYYY-MM, --MM-DD, etc.)
    bool           Use24HourClock;           // = false,  times will be formatted using a 24 hour clock
} ImPlotStyle;
CIMGUI_API IMPLOT_API ImPlotStyle_ImPlotStyle(ImPlotStyle* self);

// Input mapping structure. Default values listed. See also MapInputDefault, MapInputReverse.
typedef struct ImPlotInputMap_t
{
    ImGuiMouseButton Pan;            // LMB    enables panning when held,
    int              PanMod;         // none   optional modifier that must be held for panning/fitting
    ImGuiMouseButton Fit;            // LMB    initiates fit when double clicked
    ImGuiMouseButton Select;         // RMB    begins box selection when pressed and confirms selection when released
    ImGuiMouseButton SelectCancel;   // LMB    cancels active box selection when pressed; cannot be same as Select
    int              SelectMod;      // none   optional modifier that must be held for box selection
    int              SelectHorzMod;  // Alt    expands active box selection horizontally to plot edge when held
    int              SelectVertMod;  // Shift  expands active box selection vertically to plot edge when held
    ImGuiMouseButton Menu;           // RMB    opens context menus (if enabled) when clicked
    int              OverrideMod;    // Ctrl   when held, all input is ignored; used to enable axis/plots as DND sources
    int              ZoomMod;        // none   optional modifier that must be held for scroll wheel zooming
    float            ZoomRate;       // 0.1f   zoom rate for scroll (e.g. 0.1f = 10% plot range every scroll click); make negative to invert
} ImPlotInputMap;
CIMGUI_API IMPLOT_API ImPlotInputMap_ImPlotInputMap(ImPlotInputMap* self);

//-----------------------------------------------------------------------------
// [SECTION] Callbacks
//-----------------------------------------------------------------------------

// Callback signature for axis tick label formatter.
typedef int (*ImPlotFormatter)(double value, char* buff, int size, void* user_data);

// Callback signature for data getter.
typedef ImPlotPoint (*ImPlotGetter)(int idx, void* user_data);

// Callback signature for axis transform.
typedef double (*ImPlotTransform)(double value, void* user_data);

//-----------------------------------------------------------------------------
// [SECTION] Contexts
//-----------------------------------------------------------------------------

// Creates a new ImPlot context. Call this after ImGui::CreateContext.
IMPLOT_API
CIMGUI_API ImPlotContext* ImPlotCreateContext(void);
// Destroys an ImPlot context. Call this before ImGui::DestroyContext. nullptr = destroy current context.
IMPLOT_API
CIMGUI_API void           ImPlotDestroyContext(void);                                  // Implied ctx = nullptr
CIMGUI_API void           ImPlotDestroyContextEx(ImPlotContext* ctx /* = nullptr */);
// Returns the current ImPlot context. nullptr if no context has ben set.
IMPLOT_API
CIMGUI_API ImPlotContext* ImPlotGetCurrentContext(void);
// Sets the current ImPlot context.
IMPLOT_API
CIMGUI_API void           ImPlotSetCurrentContext(ImPlotContext* ctx);

// Sets the current **ImGui** context. This is ONLY necessary if you are compiling
// ImPlot as a DLL (not recommended) separate from your ImGui compilation. It
// sets the global variable GImGui, which is not shared across DLL boundaries.
// See GImGui documentation in imgui.cpp for more details.
IMPLOT_API
CIMGUI_API void ImPlotSetImGuiContext(ImGuiContext* ctx);

//-----------------------------------------------------------------------------
// [SECTION] Begin/End Plot
//-----------------------------------------------------------------------------

// Starts a 2D plotting context. If this function returns true, EndPlot() MUST
// be called! You are encouraged to use the following convention:
//
// if (BeginPlot(...)) {
//     PlotLine(...);
//     ...
//     EndPlot();
// }
//
// Important notes:
//
// - #title_id must be unique to the current ImGui ID scope. If you need to avoid ID
//   collisions or don't want to display a title in the plot, use double hashes
//   (e.g. "MyPlot##HiddenIdText" or "##NoTitle").
// - #size is the **frame** size of the plot widget, not the plot area. The default
//   size of plots (i.e. when ImVec2(0,0)) can be modified in your ImPlotStyle.
IMPLOT_API
CIMGUI_API bool ImPlotBeginPlot(const char* title_id);                                                                    // Implied size = ImVec2(-1, 0), flags = 0
CIMGUI_API bool ImPlotBeginPlotEx(const char* title_id, ImVec2 size /* = ImVec2(-1, 0) */, ImPlotFlags flags /* = 0 */);

// Only call EndPlot() if BeginPlot() returns true! Typically called at the end
// of an if statement conditioned on BeginPlot(). See example above.
IMPLOT_API
CIMGUI_API void ImPlotEndPlot(void);

//-----------------------------------------------------------------------------
// [SECTION] Begin/End Subplots
//-----------------------------------------------------------------------------

// Starts a subdivided plotting context. If the function returns true,
// EndSubplots() MUST be called! Call BeginPlot/EndPlot AT MOST [rows*cols]
// times in  between the begining and end of the subplot context. Plots are
// added in row major order.
//
// Example:
//
// if (BeginSubplots("My Subplot",2,3,ImVec2(800,400)) {
//     for (int i = 0; i < 6; ++i) {
//         if (BeginPlot(...)) {
//             ImPlot::PlotLine(...);
//             ...
//             EndPlot();
//         }
//     }
//     EndSubplots();
// }
//
// Produces:
//
// [0] | [1] | [2]
// ----|-----|----
// [3] | [4] | [5]
//
// Important notes:
//
// - #title_id must be unique to the current ImGui ID scope. If you need to avoid ID
//   collisions or don't want to display a title in the plot, use double hashes
//   (e.g. "MySubplot##HiddenIdText" or "##NoTitle").
// - #rows and #cols must be greater than 0.
// - #size is the size of the entire grid of subplots, not the individual plots
// - #row_ratios and #col_ratios must have AT LEAST #rows and #cols elements,
//   respectively. These are the sizes of the rows and columns expressed in ratios.
//   If the user adjusts the dimensions, the arrays are updated with new ratios.
//
// Important notes regarding BeginPlot from inside of BeginSubplots:
//
// - The #title_id parameter of _BeginPlot_ (see above) does NOT have to be
//   unique when called inside of a subplot context. Subplot IDs are hashed
//   for your convenience so you don't have call PushID or generate unique title
//   strings. Simply pass an empty string to BeginPlot unless you want to title
//   each subplot.
// - The #size parameter of _BeginPlot_ (see above) is ignored when inside of a
//   subplot context. The actual size of the subplot will be based on the
//   #size value you pass to _BeginSubplots_ and #row/#col_ratios if provided.

IMPLOT_API
CIMGUI_API bool ImPlotBeginSubplots(const char* title_id, int rows, int cols, ImVec2 size, ImPlotSubplotFlags flags /* = 0 */);                                                                          // Implied row_ratios = nullptr, col_ratios = nullptr
CIMGUI_API bool ImPlotBeginSubplotsEx(const char* title_id, int rows, int cols, ImVec2 size, ImPlotSubplotFlags flags /* = 0 */, float* row_ratios /* = nullptr */, float* col_ratios /* = nullptr */);

// Only call EndSubplots() if BeginSubplots() returns true! Typically called at the end
// of an if statement conditioned on BeginSublots(). See example above.
IMPLOT_API
CIMGUI_API void ImPlotEndSubplots(void);

//-----------------------------------------------------------------------------
// [SECTION] Setup
//-----------------------------------------------------------------------------

// The following API allows you to setup and customize various aspects of the
// current plot. The functions should be called immediately after BeginPlot
// and before any other API calls. Typical usage is as follows:

// if (BeginPlot(...)) {                     1) begin a new plot
//     SetupAxis(ImAxis_X1, "My X-Axis");    2) make Setup calls
//     SetupAxis(ImAxis_Y1, "My Y-Axis");
//     SetupLegend(ImPlotLocation_North);
//     ...
//     SetupFinish();                        3) [optional] explicitly finish setup
//     PlotLine(...);                        4) plot items
//     ...
//     EndPlot();                            5) end the plot
// }
//
// Important notes:
//
// - Always call Setup code at the top of your BeginPlot conditional statement.
// - Setup is locked once you start plotting or explicitly call SetupFinish.
//   Do NOT call Setup code after you begin plotting or after you make
//   any non-Setup API calls (e.g. utils like PlotToPixels also lock Setup)
// - Calling SetupFinish is OPTIONAL, but probably good practice. If you do not
//   call it yourself, then the first subsequent plotting or utility function will
//   call it for you.

// Enables an axis or sets the label and/or flags for an existing axis. Leave #label = nullptr for no label.
IMPLOT_API
CIMGUI_API void ImPlotSetupAxis(ImAxis axis);                                                      // Implied label = nullptr, flags = 0
CIMGUI_API void ImPlotSetupAxisEx(ImAxis axis, const char* label /* = nullptr */, ImPlotAxisFlags flags /* = 0 */);
// Sets an axis range limits. If ImPlotCond_Always is used, the axes limits will be locked. Inversion with v_min > v_max is not supported; use SetupAxisLimits instead.
IMPLOT_API
CIMGUI_API void ImPlotSetupAxisLimits(ImAxis axis, double v_min, double v_max);                    // Implied cond = ImPlotCond_Once
CIMGUI_API void ImPlotSetupAxisLimitsEx(ImAxis axis, double v_min, double v_max, ImPlotCond cond /* = ImPlotCond_Once */);
// Links an axis range limits to external values. Set to nullptr for no linkage. The pointer data must remain valid until EndPlot.
IMPLOT_API
CIMGUI_API void ImPlotSetupAxisLinks(ImAxis axis, double* link_min, double* link_max);
// Sets the format of numeric axis labels via formater specifier (default="%g"). Formated values will be double (i.e. use %f).
IMPLOT_API
CIMGUI_API void ImPlotSetupAxisFormat(ImAxis axis, const char* fmt);
// Sets the format of numeric axis labels via formatter callback. Given #value, write a label into #buff. Optionally pass user data.
IMPLOT_API
CIMGUI_API void ImPlotSetupAxisFormatImPlotFormatter(ImAxis axis, ImPlotFormatter formatter);      // Implied data = nullptr
CIMGUI_API void ImPlotSetupAxisFormatImPlotFormatterEx(ImAxis axis, ImPlotFormatter formatter, void* data /* = nullptr */);
// Sets an axis' ticks and optionally the labels. To keep the default ticks, set #keep_default=true.
IMPLOT_API
CIMGUI_API void ImPlotSetupAxisTicks(ImAxis axis, const double* values, int n_ticks);              // Implied labels = nullptr, keep_default = false
CIMGUI_API void ImPlotSetupAxisTicksEx(ImAxis axis, const double* values, int n_ticks, const char*const labels[] /* = nullptr */, bool keep_default /* = false */);
// Sets an axis' ticks and optionally the labels for the next plot. To keep the default ticks, set #keep_default=true.
IMPLOT_API
CIMGUI_API void ImPlotSetupAxisTicksDouble(ImAxis axis, double v_min, double v_max, int n_ticks);  // Implied labels = nullptr, keep_default = false
CIMGUI_API void ImPlotSetupAxisTicksDoubleEx(ImAxis axis, double v_min, double v_max, int n_ticks, const char*const labels[] /* = nullptr */, bool keep_default /* = false */);
// Sets an axis' scale using built-in options.
IMPLOT_API
CIMGUI_API void ImPlotSetupAxisScale(ImAxis axis, ImPlotScale scale);
// Sets an axis' scale using user supplied forward and inverse transfroms.
IMPLOT_API
CIMGUI_API void ImPlotSetupAxisScaleImPlotTransform(ImAxis axis, ImPlotTransform forward, ImPlotTransform inverse); // Implied data = nullptr
CIMGUI_API void ImPlotSetupAxisScaleImPlotTransformEx(ImAxis axis, ImPlotTransform forward, ImPlotTransform inverse, void* data /* = nullptr */);
// Sets an axis' limits constraints.
IMPLOT_API
CIMGUI_API void ImPlotSetupAxisLimitsConstraints(ImAxis axis, double v_min, double v_max);
// Sets an axis' zoom constraints.
IMPLOT_API
CIMGUI_API void ImPlotSetupAxisZoomConstraints(ImAxis axis, double z_min, double z_max);

// Sets the label and/or flags for primary X and Y axes (shorthand for two calls to SetupAxis).
IMPLOT_API
CIMGUI_API void ImPlotSetupAxes(const char* x_label, const char* y_label);                      // Implied x_flags = 0, y_flags = 0
CIMGUI_API void ImPlotSetupAxesEx(const char* x_label, const char* y_label, ImPlotAxisFlags x_flags /* = 0 */, ImPlotAxisFlags y_flags /* = 0 */);
// Sets the primary X and Y axes range limits. If ImPlotCond_Always is used, the axes limits will be locked (shorthand for two calls to SetupAxisLimits).
IMPLOT_API
CIMGUI_API void ImPlotSetupAxesLimits(double x_min, double x_max, double y_min, double y_max);  // Implied cond = ImPlotCond_Once
CIMGUI_API void ImPlotSetupAxesLimitsEx(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond /* = ImPlotCond_Once */);

// Sets up the plot legend. This can also be called immediately after BeginSubplots when using ImPlotSubplotFlags_ShareItems.
IMPLOT_API
CIMGUI_API void ImPlotSetupLegend(ImPlotLocation location, ImPlotLegendFlags flags /* = 0 */);
// Set the location of the current plot's mouse position text (default = South|East).
IMPLOT_API
CIMGUI_API void ImPlotSetupMouseText(ImPlotLocation location, ImPlotMouseTextFlags flags /* = 0 */);

// Explicitly finalize plot setup. Once you call this, you cannot make anymore Setup calls for the current plot!
// Note that calling this function is OPTIONAL; it will be called by the first subsequent setup-locking API call.
IMPLOT_API
CIMGUI_API void ImPlotSetupFinish(void);

//-----------------------------------------------------------------------------
// [SECTION] SetNext
//-----------------------------------------------------------------------------

// Though you should default to the `Setup` API above, there are some scenarios
// where (re)configuring a plot or axis before `BeginPlot` is needed (e.g. if
// using a preceding button or slider widget to change the plot limits). In
// this case, you can use the `SetNext` API below. While this is not as feature
// rich as the Setup API, most common needs are provided. These functions can be
// called anwhere except for inside of `Begin/EndPlot`. For example:

// if (ImGui::Button("Center Plot"))
//     ImPlot::SetNextPlotLimits(-1,1,-1,1);
// if (ImPlot::BeginPlot(...)) {
//     ...
//     ImPlot::EndPlot();
// }
//
// Important notes:
//
// - You must still enable non-default axes with SetupAxis for these functions
//   to work properly.

// Sets an upcoming axis range limits. If ImPlotCond_Always is used, the axes limits will be locked.
IMPLOT_API
CIMGUI_API void ImPlotSetNextAxisLimits(ImAxis axis, double v_min, double v_max);         // Implied cond = ImPlotCond_Once
CIMGUI_API void ImPlotSetNextAxisLimitsEx(ImAxis axis, double v_min, double v_max, ImPlotCond cond /* = ImPlotCond_Once */);
// Links an upcoming axis range limits to external values. Set to nullptr for no linkage. The pointer data must remain valid until EndPlot!
IMPLOT_API
CIMGUI_API void ImPlotSetNextAxisLinks(ImAxis axis, double* link_min, double* link_max);
// Set an upcoming axis to auto fit to its data.
IMPLOT_API
CIMGUI_API void ImPlotSetNextAxisToFit(ImAxis axis);

// Sets the upcoming primary X and Y axes range limits. If ImPlotCond_Always is used, the axes limits will be locked (shorthand for two calls to SetupAxisLimits).
IMPLOT_API
CIMGUI_API void ImPlotSetNextAxesLimits(double x_min, double x_max, double y_min, double y_max);  // Implied cond = ImPlotCond_Once
CIMGUI_API void ImPlotSetNextAxesLimitsEx(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond /* = ImPlotCond_Once */);
// Sets all upcoming axes to auto fit to their data.
IMPLOT_API
CIMGUI_API void ImPlotSetNextAxesToFit(void);

//-----------------------------------------------------------------------------
// [SECTION] Plot Items
//-----------------------------------------------------------------------------

// The main plotting API is provied below. Call these functions between
// Begin/EndPlot and after any Setup API calls. Each plots data on the current
// x and y axes, which can be changed with `SetAxis/Axes`.
//
// The templated functions are explicitly instantiated in implot_items.cpp.
// They are not intended to be used generically with custom types. You will get
// a linker error if you try! All functions support the following scalar types:
//
// float, double, ImS8, ImU8, ImS16, ImU16, ImS32, ImU32, ImS64, ImU64
//
//
// If you need to plot custom or non-homogenous data you have a few options:
//
// 1. If your data is a simple struct/class (e.g. Vector2f), you can use striding.
//    This is the most performant option if applicable.
//
//    struct Vector2f { float X, Y; };
//    ...
//    Vector2f data[42];
//    ImPlot::PlotLine("line", &data[0].x, &data[0].y, 42, 0, 0, sizeof(Vector2f));
//
// 2. Write a custom getter C function or C++ lambda and pass it and optionally your data to
//    an ImPlot function post-fixed with a G (e.g. PlotScatterG). This has a slight performance
//    cost, but probably not enough to worry about unless your data is very large. Examples:
//
//    ImPlotPoint MyDataGetter(void* data, int idx) {
//        MyData* my_data = (MyData*)data;
//        ImPlotPoint p;
//        p.x = my_data->GetTime(idx);
//        p.y = my_data->GetValue(idx);
//        return p
//    }
//    ...
//    auto my_lambda = [](int idx, void*) {
//        double t = idx / 999.0;
//        return ImPlotPoint(t, 0.5+0.5*std::sin(2*PI*10*t));
//    };
//    ...
//    if (ImPlot::BeginPlot("MyPlot")) {
//        MyData my_data;
//        ImPlot::PlotScatterG("scatter", MyDataGetter, &my_data, my_data.Size());
//        ImPlot::PlotLineG("line", my_lambda, nullptr, 1000);
//        ImPlot::EndPlot();
//    }
//
// NB: All types are converted to double before plotting. You may lose information
// if you try plotting extremely large 64-bit integral types. Proceed with caution!

// Plots a standard 2D line plot.
IMPLOT_TMP
CIMGUI_API void ImPlotPlotLineInt(const char* label_id, const T* values, int count);                                                 // Implied xscale = 1, xstart = 0, flags = 0, offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotLineIntEx(const char* label_id, const T* values, int count, double xscale /* = 1 */, double xstart /* = 0 */, ImPlotLineFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);
IMPLOT_TMP
CIMGUI_API void ImPlotPlotLine(const char* label_id, const T* xs, const T* ys, int count, ImPlotLineFlags flags /* = 0 */);          // Implied offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotLineEx(const char* label_id, const T* xs, const T* ys, int count, ImPlotLineFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);
IMPLOT_API
CIMGUI_API void ImPlotPlotLineG(const char* label_id, ImPlotGetter getter, void* data, int count, ImPlotLineFlags flags /* = 0 */);

// Plots a standard 2D scatter plot. Default marker is ImPlotMarker_Circle.
IMPLOT_TMP
CIMGUI_API void ImPlotPlotScatterInt(const char* label_id, const T* values, int count);                                                    // Implied xscale = 1, xstart = 0, flags = 0, offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotScatterIntEx(const char* label_id, const T* values, int count, double xscale /* = 1 */, double xstart /* = 0 */, ImPlotScatterFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);
IMPLOT_TMP
CIMGUI_API void ImPlotPlotScatter(const char* label_id, const T* xs, const T* ys, int count, ImPlotScatterFlags flags /* = 0 */);          // Implied offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotScatterEx(const char* label_id, const T* xs, const T* ys, int count, ImPlotScatterFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);
IMPLOT_API
CIMGUI_API void ImPlotPlotScatterG(const char* label_id, ImPlotGetter getter, void* data, int count, ImPlotScatterFlags flags /* = 0 */);

// Plots a a stairstep graph. The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i]
IMPLOT_TMP
CIMGUI_API void ImPlotPlotStairsInt(const char* label_id, const T* values, int count);                                                   // Implied xscale = 1, xstart = 0, flags = 0, offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotStairsIntEx(const char* label_id, const T* values, int count, double xscale /* = 1 */, double xstart /* = 0 */, ImPlotStairsFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);
IMPLOT_TMP
CIMGUI_API void ImPlotPlotStairs(const char* label_id, const T* xs, const T* ys, int count, ImPlotStairsFlags flags /* = 0 */);          // Implied offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotStairsEx(const char* label_id, const T* xs, const T* ys, int count, ImPlotStairsFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);
IMPLOT_API
CIMGUI_API void ImPlotPlotStairsG(const char* label_id, ImPlotGetter getter, void* data, int count, ImPlotStairsFlags flags /* = 0 */);

// Plots a shaded (filled) region between two lines, or a line and a horizontal reference. Set yref to +/-INFINITY for infinite fill extents.
IMPLOT_TMP
CIMGUI_API void ImPlotPlotShadedInt(const char* label_id, const T* values, int count);                                                              // Implied yref = 0, xscale = 1, xstart = 0, flags = 0, offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotShadedIntEx(const char* label_id, const T* values, int count, double yref /* = 0 */, double xscale /* = 1 */, double xstart /* = 0 */, ImPlotShadedFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);
IMPLOT_TMP
CIMGUI_API void ImPlotPlotShaded(const char* label_id, const T* xs, const T* ys, int count);                                                        // Implied yref = 0, flags = 0, offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotShadedEx(const char* label_id, const T* xs, const T* ys, int count, double yref /* = 0 */, ImPlotShadedFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);
IMPLOT_TMP
CIMGUI_API void ImPlotPlotShadedTPtr(const char* label_id, const T* xs, const T* ys1, const T* ys2, int count, ImPlotShadedFlags flags /* = 0 */);  // Implied offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotShadedTPtrEx(const char* label_id, const T* xs, const T* ys1, const T* ys2, int count, ImPlotShadedFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);
IMPLOT_API
CIMGUI_API void ImPlotPlotShadedG(const char* label_id, ImPlotGetter getter1, void* data1, ImPlotGetter getter2, void* data2, int count, ImPlotShadedFlags flags /* = 0 */);

// Plots a bar graph. Vertical by default. #bar_size and #shift are in plot units.
IMPLOT_TMP
CIMGUI_API void ImPlotPlotBars(const char* label_id, const T* values, int count);                                                                     // Implied bar_size = 0.67, shift = 0, flags = 0, offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotBarsEx(const char* label_id, const T* values, int count, double bar_size /* = 0.67 */, double shift /* = 0 */, ImPlotBarsFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);
IMPLOT_TMP
CIMGUI_API void ImPlotPlotBarsTPtr(const char* label_id, const T* xs, const T* ys, int count, double bar_size, ImPlotBarsFlags flags /* = 0 */);      // Implied offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotBarsTPtrEx(const char* label_id, const T* xs, const T* ys, int count, double bar_size, ImPlotBarsFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);
IMPLOT_API
CIMGUI_API void ImPlotPlotBarsG(const char* label_id, ImPlotGetter getter, void* data, int count, double bar_size, ImPlotBarsFlags flags /* = 0 */);

// Plots a group of bars. #values is a row-major matrix with #item_count rows and #group_count cols. #label_ids should have #item_count elements.
IMPLOT_TMP
CIMGUI_API void ImPlotPlotBarGroups(const char*const label_ids[], const T* values, int item_count, int group_count);  // Implied group_size = 0.67, shift = 0, flags = 0
CIMGUI_API void ImPlotPlotBarGroupsEx(const char*const label_ids[], const T* values, int item_count, int group_count, double group_size /* = 0.67 */, double shift /* = 0 */, ImPlotBarGroupsFlags flags /* = 0 */);

// Plots vertical error bar. The label_id should be the same as the label_id of the associated line or bar plot.
IMPLOT_TMP
CIMGUI_API void ImPlotPlotErrorBars(const char* label_id, const T* xs, const T* ys, const T* err, int count, ImPlotErrorBarsFlags flags /* = 0 */);                    // Implied offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotErrorBarsEx(const char* label_id, const T* xs, const T* ys, const T* err, int count, ImPlotErrorBarsFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);
IMPLOT_TMP
CIMGUI_API void ImPlotPlotErrorBarsTPtr(const char* label_id, const T* xs, const T* ys, const T* neg, const T* pos, int count, ImPlotErrorBarsFlags flags /* = 0 */);  // Implied offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotErrorBarsTPtrEx(const char* label_id, const T* xs, const T* ys, const T* neg, const T* pos, int count, ImPlotErrorBarsFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);

// Plots stems. Vertical by default.
IMPLOT_TMP
CIMGUI_API void ImPlotPlotStemsInt(const char* label_id, const T* values, int count);        // Implied ref = 0, scale = 1, start = 0, flags = 0, offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotStemsIntEx(const char* label_id, const T* values, int count, double ref /* = 0 */, double scale /* = 1 */, double start /* = 0 */, ImPlotStemsFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);
IMPLOT_TMP
CIMGUI_API void ImPlotPlotStems(const char* label_id, const T* xs, const T* ys, int count);  // Implied ref = 0, flags = 0, offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotStemsEx(const char* label_id, const T* xs, const T* ys, int count, double ref /* = 0 */, ImPlotStemsFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);

// Plots infinite vertical or horizontal lines (e.g. for references or asymptotes).
IMPLOT_TMP
CIMGUI_API void ImPlotPlotInfLines(const char* label_id, const T* values, int count, ImPlotInfLinesFlags flags /* = 0 */);                                                        // Implied offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotInfLinesEx(const char* label_id, const T* values, int count, ImPlotInfLinesFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);

// Plots a pie chart. Center and radius are in plot units. #label_fmt can be set to nullptr for no labels.
IMPLOT_TMP
CIMGUI_API void ImPlotPlotPieChartImPlotFormatter(const char*const label_ids[], const T* values, int count, double x, double y, double radius, ImPlotFormatter fmt);  // Implied fmt_data = nullptr, angle0 = 90, flags = 0
CIMGUI_API void ImPlotPlotPieChartImPlotFormatterEx(const char*const label_ids[], const T* values, int count, double x, double y, double radius, ImPlotFormatter fmt, void* fmt_data /* = nullptr */, double angle0 /* = 90 */, ImPlotPieChartFlags flags /* = 0 */);
IMPLOT_TMP
CIMGUI_API void ImPlotPlotPieChart(const char*const label_ids[], const T* values, int count, double x, double y, double radius);                                      // Implied label_fmt = "%.1f", angle0 = 90, flags = 0
CIMGUI_API void ImPlotPlotPieChartEx(const char*const label_ids[], const T* values, int count, double x, double y, double radius, const char* label_fmt /* = "%.1f" */, double angle0 /* = 90 */, ImPlotPieChartFlags flags /* = 0 */);

// Plots a 2D heatmap chart. Values are expected to be in row-major order by default. Leave #scale_min and scale_max both at 0 for automatic color scaling, or set them to a predefined range. #label_fmt can be set to nullptr for no labels.
IMPLOT_TMP
CIMGUI_API void ImPlotPlotHeatmap(const char* label_id, const T* values, int rows, int cols);  // Implied scale_min = 0, scale_max = 0, label_fmt = "%.1f", bounds_min = ImPlotPoint(0, 0), bounds_max = ImPlotPoint(1, 1), flags = 0
CIMGUI_API void ImPlotPlotHeatmapEx(const char* label_id, const T* values, int rows, int cols, double scale_min /* = 0 */, double scale_max /* = 0 */, const char* label_fmt /* = "%.1f" */, ImPlotPoint bounds_min /* = ImPlotPoint(0, 0) */, ImPlotPoint bounds_max /* = ImPlotPoint(1, 1) */, ImPlotHeatmapFlags flags /* = 0 */);

// Plots a horizontal histogram. #bins can be a positive integer or an ImPlotBin_ method. If #range is left unspecified, the min/max of #values will be used as the range.
// Otherwise, outlier values outside of the range are not binned. The largest bin count or density is returned.
IMPLOT_TMP
CIMGUI_API double ImPlotPlotHistogram(const char* label_id, const T* values, int count);  // Implied bins = ImPlotBin_Sturges, bar_scale = 1.0, range = ImPlotRange(), flags = 0
CIMGUI_API double ImPlotPlotHistogramEx(const char* label_id, const T* values, int count, int bins /* = ImPlotBin_Sturges */, double bar_scale /* = 1.0 */, ImPlotRange range /* = ImPlotRange() */, ImPlotHistogramFlags flags /* = 0 */);

// Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
IMPLOT_TMP
CIMGUI_API double ImPlotPlotHistogram2D(const char* label_id, const T* xs, const T* ys, int count);  // Implied x_bins = ImPlotBin_Sturges, y_bins = ImPlotBin_Sturges, range = ImPlotRect(), flags = 0
CIMGUI_API double ImPlotPlotHistogram2DEx(const char* label_id, const T* xs, const T* ys, int count, int x_bins /* = ImPlotBin_Sturges */, int y_bins /* = ImPlotBin_Sturges */, ImPlotRect range /* = ImPlotRect() */, ImPlotHistogramFlags flags /* = 0 */);

// Plots digital data. Digital plots do not respond to y drag or zoom, and are always referenced to the bottom of the plot.
IMPLOT_TMP
CIMGUI_API void ImPlotPlotDigital(const char* label_id, const T* xs, const T* ys, int count, ImPlotDigitalFlags flags /* = 0 */);          // Implied offset = 0, stride = sizeof(T)
CIMGUI_API void ImPlotPlotDigitalEx(const char* label_id, const T* xs, const T* ys, int count, ImPlotDigitalFlags flags /* = 0 */, int offset /* = 0 */, int stride /* = sizeof(T) */);
IMPLOT_API
CIMGUI_API void ImPlotPlotDigitalG(const char* label_id, ImPlotGetter getter, void* data, int count, ImPlotDigitalFlags flags /* = 0 */);

// Plots an axis-aligned image. #bounds_min/bounds_max are in plot coordinates (y-up) and #uv0/uv1 are in texture coordinates (y-down).
IMPLOT_API
CIMGUI_API void ImPlotPlotImage(const char* label_id, ImTextureID user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max);  // Implied uv0 = ImVec2(0, 0), uv1 = ImVec2(1, 1), tint_col = ImVec4(1, 1, 1, 1), flags = 0
CIMGUI_API void ImPlotPlotImageEx(const char* label_id, ImTextureID user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImVec2 uv0 /* = ImVec2(0, 0) */, ImVec2 uv1 /* = ImVec2(1, 1) */, ImVec4 tint_col /* = ImVec4(1, 1, 1, 1) */, ImPlotImageFlags flags /* = 0 */);

// Plots a centered text label at point x,y with an optional pixel offset. Text color can be changed with ImPlot::PushStyleColor(ImPlotCol_InlayText, ...).
IMPLOT_API
CIMGUI_API void ImPlotPlotText(const char* text, double x, double y);                                                                             // Implied pix_offset = ImVec2(0, 0), flags = 0
CIMGUI_API void ImPlotPlotTextEx(const char* text, double x, double y, ImVec2 pix_offset /* = ImVec2(0, 0) */, ImPlotTextFlags flags /* = 0 */);

// Plots a dummy item (i.e. adds a legend entry colored by ImPlotCol_Line)
IMPLOT_API
CIMGUI_API void ImPlotPlotDummy(const char* label_id, ImPlotDummyFlags flags /* = 0 */);

//-----------------------------------------------------------------------------
// [SECTION] Plot Tools
//-----------------------------------------------------------------------------

// The following can be used to render interactive elements and/or annotations.
// Like the item plotting functions above, they apply to the current x and y
// axes, which can be changed with `SetAxis/SetAxes`. These functions return true
// when user interaction causes the provided coordinates to change. Additional
// user interactions can be retrieved through the optional output parameters.

// Shows a draggable point at x,y. #col defaults to ImGuiCol_Text.
IMPLOT_API
CIMGUI_API bool ImPlotDragPoint(int id, double* x, double* y, ImVec4 col);                                                                // Implied size = 4, flags = 0, out_clicked = nullptr, out_hovered = nullptr, held = nullptr
CIMGUI_API bool ImPlotDragPointEx(int id, double* x, double* y, ImVec4 col, float size /* = 4 */, ImPlotDragToolFlags flags /* = 0 */, bool* out_clicked /* = nullptr */, bool* out_hovered /* = nullptr */, bool* held /* = nullptr */);
// Shows a draggable vertical guide line at an x-value. #col defaults to ImGuiCol_Text.
IMPLOT_API
CIMGUI_API bool ImPlotDragLineX(int id, double* x, ImVec4 col);                                                                           // Implied thickness = 1, flags = 0, out_clicked = nullptr, out_hovered = nullptr, held = nullptr
CIMGUI_API bool ImPlotDragLineXEx(int id, double* x, ImVec4 col, float thickness /* = 1 */, ImPlotDragToolFlags flags /* = 0 */, bool* out_clicked /* = nullptr */, bool* out_hovered /* = nullptr */, bool* held /* = nullptr */);
// Shows a draggable horizontal guide line at a y-value. #col defaults to ImGuiCol_Text.
IMPLOT_API
CIMGUI_API bool ImPlotDragLineY(int id, double* y, ImVec4 col);                                                                           // Implied thickness = 1, flags = 0, out_clicked = nullptr, out_hovered = nullptr, held = nullptr
CIMGUI_API bool ImPlotDragLineYEx(int id, double* y, ImVec4 col, float thickness /* = 1 */, ImPlotDragToolFlags flags /* = 0 */, bool* out_clicked /* = nullptr */, bool* out_hovered /* = nullptr */, bool* held /* = nullptr */);
// Shows a draggable and resizeable rectangle.
IMPLOT_API
CIMGUI_API bool ImPlotDragRect(int id, double* x1, double* y1, double* x2, double* y2, ImVec4 col, ImPlotDragToolFlags flags /* = 0 */);  // Implied out_clicked = nullptr, out_hovered = nullptr, held = nullptr
CIMGUI_API bool ImPlotDragRectEx(int id, double* x1, double* y1, double* x2, double* y2, ImVec4 col, ImPlotDragToolFlags flags /* = 0 */, bool* out_clicked /* = nullptr */, bool* out_hovered /* = nullptr */, bool* held /* = nullptr */);

// Shows an annotation callout at a chosen point. Clamping keeps annotations in the plot area. Annotations are always rendered on top.
IMPLOT_API
CIMGUI_API void ImPlotAnnotation(double x, double y, ImVec4 col, ImVec2 pix_offset, bool clamp);                              // Implied round = false
CIMGUI_API void ImPlotAnnotationEx(double x, double y, ImVec4 col, ImVec2 pix_offset, bool clamp, bool round /* = false */);
IMPLOT_API
CIMGUI_API void ImPlotAnnotationStr(double x, double y, ImVec4 col, ImVec2 pix_offset, bool clamp, const char* fmt, ...) IM_FMTARGS(6);
IMPLOT_API
CIMGUI_API void ImPlotAnnotationV(double x, double y, ImVec4 col, ImVec2 pix_offset, bool clamp, const char* fmt, va_list args) IM_FMTLIST(6);

// Shows a x-axis tag at the specified coordinate value.
IMPLOT_API
CIMGUI_API void ImPlotTagX(double x, ImVec4 col);                                         // Implied round = false
CIMGUI_API void ImPlotTagXEx(double x, ImVec4 col, bool round /* = false */);
IMPLOT_API
CIMGUI_API void ImPlotTagXStr(double x, ImVec4 col, const char* fmt, ...) IM_FMTARGS(3);
IMPLOT_API
CIMGUI_API void ImPlotTagXV(double x, ImVec4 col, const char* fmt, va_list args) IM_FMTLIST(3);

// Shows a y-axis tag at the specified coordinate value.
IMPLOT_API
CIMGUI_API void ImPlotTagY(double y, ImVec4 col);                                         // Implied round = false
CIMGUI_API void ImPlotTagYEx(double y, ImVec4 col, bool round /* = false */);
IMPLOT_API
CIMGUI_API void ImPlotTagYStr(double y, ImVec4 col, const char* fmt, ...) IM_FMTARGS(3);
IMPLOT_API
CIMGUI_API void ImPlotTagYV(double y, ImVec4 col, const char* fmt, va_list args) IM_FMTLIST(3);

//-----------------------------------------------------------------------------
// [SECTION] Plot Utils
//-----------------------------------------------------------------------------

// Select which axis/axes will be used for subsequent plot elements.
IMPLOT_API
CIMGUI_API void ImPlotSetAxis(ImAxis axis);
IMPLOT_API
CIMGUI_API void ImPlotSetAxes(ImAxis x_axis, ImAxis y_axis);

// Convert pixels to a position in the current plot's coordinate system. Passing IMPLOT_AUTO uses the current axes.
IMPLOT_API
CIMGUI_API ImPlotPoint ImPlotPixelsToPlot(ImVec2 pix);             // Implied x_axis = IMPLOT_AUTO, y_axis = IMPLOT_AUTO
CIMGUI_API ImPlotPoint ImPlotPixelsToPlotEx(ImVec2 pix, ImAxis x_axis /* = IMPLOT_AUTO */, ImAxis y_axis /* = IMPLOT_AUTO */);
IMPLOT_API
CIMGUI_API ImPlotPoint ImPlotPixelsToPlotFloat(float x, float y);  // Implied x_axis = IMPLOT_AUTO, y_axis = IMPLOT_AUTO
CIMGUI_API ImPlotPoint ImPlotPixelsToPlotFloatEx(float x, float y, ImAxis x_axis /* = IMPLOT_AUTO */, ImAxis y_axis /* = IMPLOT_AUTO */);

// Convert a position in the current plot's coordinate system to pixels. Passing IMPLOT_AUTO uses the current axes.
IMPLOT_API
CIMGUI_API ImVec2 ImPlotPlotToPixels(ImPlotPoint plt);           // Implied x_axis = IMPLOT_AUTO, y_axis = IMPLOT_AUTO
CIMGUI_API ImVec2 ImPlotPlotToPixelsEx(ImPlotPoint plt, ImAxis x_axis /* = IMPLOT_AUTO */, ImAxis y_axis /* = IMPLOT_AUTO */);
IMPLOT_API
CIMGUI_API ImVec2 ImPlotPlotToPixelsDouble(double x, double y);  // Implied x_axis = IMPLOT_AUTO, y_axis = IMPLOT_AUTO
CIMGUI_API ImVec2 ImPlotPlotToPixelsDoubleEx(double x, double y, ImAxis x_axis /* = IMPLOT_AUTO */, ImAxis y_axis /* = IMPLOT_AUTO */);

// Get the current Plot position (top-left) in pixels.
IMPLOT_API
CIMGUI_API ImVec2 ImPlotGetPlotPos(void);
// Get the curent Plot size in pixels.
IMPLOT_API
CIMGUI_API ImVec2 ImPlotGetPlotSize(void);

// Returns the mouse position in x,y coordinates of the current plot. Passing IMPLOT_AUTO uses the current axes.
IMPLOT_API
CIMGUI_API ImPlotPoint ImPlotGetPlotMousePos(void);  // Implied x_axis = IMPLOT_AUTO, y_axis = IMPLOT_AUTO
CIMGUI_API ImPlotPoint ImPlotGetPlotMousePosEx(ImAxis x_axis /* = IMPLOT_AUTO */, ImAxis y_axis /* = IMPLOT_AUTO */);
// Returns the current plot axis range.
IMPLOT_API
CIMGUI_API ImPlotRect  ImPlotGetPlotLimits(void);    // Implied x_axis = IMPLOT_AUTO, y_axis = IMPLOT_AUTO
CIMGUI_API ImPlotRect  ImPlotGetPlotLimitsEx(ImAxis x_axis /* = IMPLOT_AUTO */, ImAxis y_axis /* = IMPLOT_AUTO */);

// Returns true if the plot area in the current plot is hovered.
IMPLOT_API
CIMGUI_API bool ImPlotIsPlotHovered(void);
// Returns true if the axis label area in the current plot is hovered.
IMPLOT_API
CIMGUI_API bool ImPlotIsAxisHovered(ImAxis axis);
// Returns true if the bounding frame of a subplot is hovered.
IMPLOT_API
CIMGUI_API bool ImPlotIsSubplotsHovered(void);

// Returns true if the current plot is being box selected.
IMPLOT_API
CIMGUI_API bool       ImPlotIsPlotSelected(void);
// Returns the current plot box selection bounds. Passing IMPLOT_AUTO uses the current axes.
IMPLOT_API
CIMGUI_API ImPlotRect ImPlotGetPlotSelection(void);     // Implied x_axis = IMPLOT_AUTO, y_axis = IMPLOT_AUTO
CIMGUI_API ImPlotRect ImPlotGetPlotSelectionEx(ImAxis x_axis /* = IMPLOT_AUTO */, ImAxis y_axis /* = IMPLOT_AUTO */);
// Cancels a the current plot box selection.
IMPLOT_API
CIMGUI_API void       ImPlotCancelPlotSelection(void);

// Hides or shows the next plot item (i.e. as if it were toggled from the legend).
// Use ImPlotCond_Always if you need to forcefully set this every frame.
IMPLOT_API
CIMGUI_API void ImPlotHideNextItem(void);                                                                 // Implied hidden = true, cond = ImPlotCond_Once
CIMGUI_API void ImPlotHideNextItemEx(bool hidden /* = true */, ImPlotCond cond /* = ImPlotCond_Once */);

// Use the following around calls to Begin/EndPlot to align l/r/t/b padding.
// Consider using Begin/EndSubplots first. They are more feature rich and
// accomplish the same behaviour by default. The functions below offer lower
// level control of plot alignment.

// Align axis padding over multiple plots in a single row or column. #group_id must
// be unique. If this function returns true, EndAlignedPlots() must be called.
IMPLOT_API
CIMGUI_API bool ImPlotBeginAlignedPlots(const char* group_id);  // Implied vertical = true
CIMGUI_API bool ImPlotBeginAlignedPlotsEx(const char* group_id, bool vertical /* = true */);
// Only call EndAlignedPlots() if BeginAlignedPlots() returns true!
IMPLOT_API
CIMGUI_API void ImPlotEndAlignedPlots(void);

//-----------------------------------------------------------------------------
// [SECTION] Legend Utils
//-----------------------------------------------------------------------------

// Begin a popup for a legend entry.
IMPLOT_API
CIMGUI_API bool ImPlotBeginLegendPopup(const char* label_id);      // Implied mouse_button = 1
CIMGUI_API bool ImPlotBeginLegendPopupEx(const char* label_id, ImGuiMouseButton mouse_button /* = 1 */);
// End a popup for a legend entry.
IMPLOT_API
CIMGUI_API void ImPlotEndLegendPopup(void);
// Returns true if a plot item legend entry is hovered.
IMPLOT_API
CIMGUI_API bool ImPlotIsLegendEntryHovered(const char* label_id);

//-----------------------------------------------------------------------------
// [SECTION] Drag and Drop
//-----------------------------------------------------------------------------

// Turns the current plot's plotting area into a drag and drop target. Don't forget to call EndDragDropTarget!
IMPLOT_API
CIMGUI_API bool ImPlotBeginDragDropTargetPlot(void);
// Turns the current plot's X-axis into a drag and drop target. Don't forget to call EndDragDropTarget!
IMPLOT_API
CIMGUI_API bool ImPlotBeginDragDropTargetAxis(ImAxis axis);
// Turns the current plot's legend into a drag and drop target. Don't forget to call EndDragDropTarget!
IMPLOT_API
CIMGUI_API bool ImPlotBeginDragDropTargetLegend(void);
// Ends a drag and drop target (currently just an alias for ImGui::EndDragDropTarget).
IMPLOT_API
CIMGUI_API void ImPlotEndDragDropTarget(void);

// NB: By default, plot and axes drag and drop *sources* require holding the Ctrl modifier to initiate the drag.
// You can change the modifier if desired. If ImGuiMod_None is provided, the axes will be locked from panning.

// Turns the current plot's plotting area into a drag and drop source. You must hold Ctrl. Don't forget to call EndDragDropSource!
IMPLOT_API
CIMGUI_API bool ImPlotBeginDragDropSourcePlot(ImGuiDragDropFlags flags /* = 0 */);
// Turns the current plot's X-axis into a drag and drop source. You must hold Ctrl. Don't forget to call EndDragDropSource!
IMPLOT_API
CIMGUI_API bool ImPlotBeginDragDropSourceAxis(ImAxis axis, ImGuiDragDropFlags flags /* = 0 */);
// Turns an item in the current plot's legend into drag and drop source. Don't forget to call EndDragDropSource!
IMPLOT_API
CIMGUI_API bool ImPlotBeginDragDropSourceItem(const char* label_id, ImGuiDragDropFlags flags /* = 0 */);
// Ends a drag and drop source (currently just an alias for ImGui::EndDragDropSource).
IMPLOT_API
CIMGUI_API void ImPlotEndDragDropSource(void);

//-----------------------------------------------------------------------------
// [SECTION] Styling
//-----------------------------------------------------------------------------

// Styling colors in ImPlot works similarly to styling colors in ImGui, but
// with one important difference. Like ImGui, all style colors are stored in an
// indexable array in ImPlotStyle. You can permanently modify these values through
// GetStyle().Colors, or temporarily modify them with Push/Pop functions below.
// However, by default all style colors in ImPlot default to a special color
// IMPLOT_AUTO_COL. The behavior of this color depends upon the style color to
// which it as applied:
//
//     1) For style colors associated with plot items (e.g. ImPlotCol_Line),
//        IMPLOT_AUTO_COL tells ImPlot to color the item with the next unused
//        color in the current colormap. Thus, every item will have a different
//        color up to the number of colors in the colormap, at which point the
//        colormap will roll over. For most use cases, you should not need to
//        set these style colors to anything but IMPLOT_COL_AUTO; you are
//        probably better off changing the current colormap. However, if you
//        need to explicitly color a particular item you may either Push/Pop
//        the style color around the item in question, or use the SetNextXXXStyle
//        API below. If you permanently set one of these style colors to a specific
//        color, or forget to call Pop, then all subsequent items will be styled
//        with the color you set.
//
//     2) For style colors associated with plot styling (e.g. ImPlotCol_PlotBg),
//        IMPLOT_AUTO_COL tells ImPlot to set that color from color data in your
//        **ImGuiStyle**. The ImGuiCol_ that these style colors default to are
//        detailed above, and in general have been mapped to produce plots visually
//        consistent with your current ImGui style. Of course, you are free to
//        manually set these colors to whatever you like, and further can Push/Pop
//        them around individual plots for plot-specific styling (e.g. coloring axes).

// Provides access to plot style structure for permanant modifications to colors, sizes, etc.
IMPLOT_API
CIMGUI_API ImPlotStyle* ImPlotGetStyle(void);

// Style plot colors for current ImGui style (default).
IMPLOT_API
CIMGUI_API void ImPlotStyleColorsAuto(void);                                   // Implied dst = nullptr
CIMGUI_API void ImPlotStyleColorsAutoEx(ImPlotStyle* dst /* = nullptr */);
// Style plot colors for ImGui "Classic".
IMPLOT_API
CIMGUI_API void ImPlotStyleColorsClassic(void);                                // Implied dst = nullptr
CIMGUI_API void ImPlotStyleColorsClassicEx(ImPlotStyle* dst /* = nullptr */);
// Style plot colors for ImGui "Dark".
IMPLOT_API
CIMGUI_API void ImPlotStyleColorsDark(void);                                   // Implied dst = nullptr
CIMGUI_API void ImPlotStyleColorsDarkEx(ImPlotStyle* dst /* = nullptr */);
// Style plot colors for ImGui "Light".
IMPLOT_API
CIMGUI_API void ImPlotStyleColorsLight(void);                                  // Implied dst = nullptr
CIMGUI_API void ImPlotStyleColorsLightEx(ImPlotStyle* dst /* = nullptr */);

// Use PushStyleX to temporarily modify your ImPlotStyle. The modification
// will last until the matching call to PopStyleX. You MUST call a pop for
// every push, otherwise you will leak memory! This behaves just like ImGui.

// Temporarily modify a style color. Don't forget to call PopStyleColor!
IMPLOT_API
CIMGUI_API void ImPlotPushStyleColor(ImPlotCol idx, ImU32 col);
IMPLOT_API
CIMGUI_API void ImPlotPushStyleColorImVec4(ImPlotCol idx, ImVec4 col);
// Undo temporary style color modification(s). Undo multiple pushes at once by increasing count.
IMPLOT_API
CIMGUI_API void ImPlotPopStyleColor(void);                   // Implied count = 1
CIMGUI_API void ImPlotPopStyleColorEx(int count /* = 1 */);

// Temporarily modify a style variable of float type. Don't forget to call PopStyleVar!
IMPLOT_API
CIMGUI_API void ImPlotPushStyleVar(ImPlotStyleVar idx, float val);
// Temporarily modify a style variable of int type. Don't forget to call PopStyleVar!
IMPLOT_API
CIMGUI_API void ImPlotPushStyleVarInt(ImPlotStyleVar idx, int val);
// Temporarily modify a style variable of ImVec2 type. Don't forget to call PopStyleVar!
IMPLOT_API
CIMGUI_API void ImPlotPushStyleVarImVec2(ImPlotStyleVar idx, ImVec2 val);
// Undo temporary style variable modification(s). Undo multiple pushes at once by increasing count.
IMPLOT_API
CIMGUI_API void ImPlotPopStyleVar(void);                   // Implied count = 1
CIMGUI_API void ImPlotPopStyleVarEx(int count /* = 1 */);

// The following can be used to modify the style of the next plot item ONLY. They do
// NOT require calls to PopStyleX. Leave style attributes you don't want modified to
// IMPLOT_AUTO or IMPLOT_AUTO_COL. Automatic styles will be deduced from the current
// values in your ImPlotStyle or from Colormap data.

// Set the line color and weight for the next item only.
IMPLOT_API
CIMGUI_API void ImPlotSetNextLineStyle(void);                                                                       // Implied col = IMPLOT_AUTO_COL, weight = IMPLOT_AUTO
CIMGUI_API void ImPlotSetNextLineStyleEx(ImVec4 col /* = IMPLOT_AUTO_COL */, float weight /* = IMPLOT_AUTO */);
// Set the fill color for the next item only.
IMPLOT_API
CIMGUI_API void ImPlotSetNextFillStyle(void);                                                                       // Implied col = IMPLOT_AUTO_COL, alpha_mod = IMPLOT_AUTO
CIMGUI_API void ImPlotSetNextFillStyleEx(ImVec4 col /* = IMPLOT_AUTO_COL */, float alpha_mod /* = IMPLOT_AUTO */);
// Set the marker style for the next item only.
IMPLOT_API
CIMGUI_API void ImPlotSetNextMarkerStyle(void);                                                                     // Implied marker = IMPLOT_AUTO, size = IMPLOT_AUTO, fill = IMPLOT_AUTO_COL, weight = IMPLOT_AUTO, outline = IMPLOT_AUTO_COL
CIMGUI_API void ImPlotSetNextMarkerStyleEx(ImPlotMarker marker /* = IMPLOT_AUTO */, float size /* = IMPLOT_AUTO */, ImVec4 fill /* = IMPLOT_AUTO_COL */, float weight /* = IMPLOT_AUTO */, ImVec4 outline /* = IMPLOT_AUTO_COL */);
// Set the error bar style for the next item only.
IMPLOT_API
CIMGUI_API void ImPlotSetNextErrorBarStyle(void);                                                                   // Implied col = IMPLOT_AUTO_COL, size = IMPLOT_AUTO, weight = IMPLOT_AUTO
CIMGUI_API void ImPlotSetNextErrorBarStyleEx(ImVec4 col /* = IMPLOT_AUTO_COL */, float size /* = IMPLOT_AUTO */, float weight /* = IMPLOT_AUTO */);

// Gets the last item primary color (i.e. its legend icon color)
IMPLOT_API
CIMGUI_API ImVec4 ImPlotGetLastItemColor(void);

// Returns the null terminated string name for an ImPlotCol.
IMPLOT_API
CIMGUI_API const char* ImPlotGetStyleColorName(ImPlotCol idx);
// Returns the null terminated string name for an ImPlotMarker.
IMPLOT_API
CIMGUI_API const char* ImPlotGetMarkerName(ImPlotMarker idx);

//-----------------------------------------------------------------------------
// [SECTION] Colormaps
//-----------------------------------------------------------------------------

// Item styling is based on colormaps when the relevant ImPlotCol_XXX is set to
// IMPLOT_AUTO_COL (default). Several built-in colormaps are available. You can
// add and then push/pop your own colormaps as well. To permanently set a colormap,
// modify the Colormap index member of your ImPlotStyle.

// Colormap data will be ignored and a custom color will be used if you have done one of the following:
//     1) Modified an item style color in your ImPlotStyle to anything other than IMPLOT_AUTO_COL.
//     2) Pushed an item style color using PushStyleColor().
//     3) Set the next item style with a SetNextXXXStyle function.

// Add a new colormap. The color data will be copied. The colormap can be used by pushing either the returned index or the
// string name with PushColormap. The colormap name must be unique and the size must be greater than 1. You will receive
// an assert otherwise! By default colormaps are considered to be qualitative (i.e. discrete). If you want to create a
// continuous colormap, set #qual=false. This will treat the colors you provide as keys, and ImPlot will build a linearly
// interpolated lookup table. The memory footprint of this table will be exactly ((size-1)*255+1)*4 bytes.
IMPLOT_API
CIMGUI_API ImPlotColormap ImPlotAddColormap(const char* name, const ImVec4* cols, int size);                                   // Implied qual = true
CIMGUI_API ImPlotColormap ImPlotAddColormapEx(const char* name, const ImVec4* cols, int size, bool qual /* = true */);
IMPLOT_API
CIMGUI_API ImPlotColormap ImPlotAddColormapImU32Ptr(const char* name, const ImU32* cols, int size);                            // Implied qual = true
CIMGUI_API ImPlotColormap ImPlotAddColormapImU32PtrEx(const char* name, const ImU32* cols, int size, bool qual /* = true */);

// Returns the number of available colormaps (i.e. the built-in + user-added count).
IMPLOT_API
CIMGUI_API int            ImPlotGetColormapCount(void);
// Returns a null terminated string name for a colormap given an index. Returns nullptr if index is invalid.
IMPLOT_API
CIMGUI_API const char*    ImPlotGetColormapName(ImPlotColormap cmap);
// Returns an index number for a colormap given a valid string name. Returns -1 if name is invalid.
IMPLOT_API
CIMGUI_API ImPlotColormap ImPlotGetColormapIndex(const char* name);

// Temporarily switch to one of the built-in (i.e. ImPlotColormap_XXX) or user-added colormaps (i.e. a return value of AddColormap). Don't forget to call PopColormap!
IMPLOT_API
CIMGUI_API void ImPlotPushColormap(ImPlotColormap cmap);
// Push a colormap by string name. Use built-in names such as "Default", "Deep", "Jet", etc. or a string you provided to AddColormap. Don't forget to call PopColormap!
IMPLOT_API
CIMGUI_API void ImPlotPushColormapStr(const char* name);
// Undo temporary colormap modification(s). Undo multiple pushes at once by increasing count.
IMPLOT_API
CIMGUI_API void ImPlotPopColormap(void);                   // Implied count = 1
CIMGUI_API void ImPlotPopColormapEx(int count /* = 1 */);

// Returns the next color from the current colormap and advances the colormap for the current plot.
// Can also be used with no return value to skip colors if desired. You need to call this between Begin/EndPlot!
IMPLOT_API
CIMGUI_API ImVec4 ImPlotNextColormapColor(void);

// Colormap utils. If cmap = IMPLOT_AUTO (default), the current colormap is assumed.
// Pass an explicit colormap index (built-in or user-added) to specify otherwise.

// Returns the size of a colormap.
IMPLOT_API
CIMGUI_API int    ImPlotGetColormapSize(void);                                                 // Implied cmap = IMPLOT_AUTO
CIMGUI_API int    ImPlotGetColormapSizeEx(ImPlotColormap cmap /* = IMPLOT_AUTO */);
// Returns a color from a colormap given an index >= 0 (modulo will be performed).
IMPLOT_API
CIMGUI_API ImVec4 ImPlotGetColormapColor(int idx);                                             // Implied cmap = IMPLOT_AUTO
CIMGUI_API ImVec4 ImPlotGetColormapColorEx(int idx, ImPlotColormap cmap /* = IMPLOT_AUTO */);
// Sample a color from the current colormap given t between 0 and 1.
IMPLOT_API
CIMGUI_API ImVec4 ImPlotSampleColormap(float t);                                               // Implied cmap = IMPLOT_AUTO
CIMGUI_API ImVec4 ImPlotSampleColormapEx(float t, ImPlotColormap cmap /* = IMPLOT_AUTO */);

// Shows a vertical color scale with linear spaced ticks using the specified color map. Use double hashes to hide label (e.g. "##NoLabel"). If scale_min > scale_max, the scale to color mapping will be reversed.
IMPLOT_API
CIMGUI_API void ImPlotColormapScale(const char* label, double scale_min, double scale_max);                                            // Implied size = ImVec2(0, 0), format = "%g", flags = 0, cmap = IMPLOT_AUTO
CIMGUI_API void ImPlotColormapScaleEx(const char* label, double scale_min, double scale_max, ImVec2 size /* = ImVec2(0, 0) */, const char* format /* = "%g" */, ImPlotColormapScaleFlags flags /* = 0 */, ImPlotColormap cmap /* = IMPLOT_AUTO */);
// Shows a horizontal slider with a colormap gradient background. Optionally returns the color sampled at t in [0 1].
IMPLOT_API
CIMGUI_API bool ImPlotColormapSlider(const char* label, float* t);                                                                     // Implied out = nullptr, format = "", cmap = IMPLOT_AUTO
CIMGUI_API bool ImPlotColormapSliderEx(const char* label, float* t, ImVec4* out /* = nullptr */, const char* format /* = "" */, ImPlotColormap cmap /* = IMPLOT_AUTO */);
// Shows a button with a colormap gradient brackground.
IMPLOT_API
CIMGUI_API bool ImPlotColormapButton(const char* label);                                                                               // Implied size = ImVec2(0, 0), cmap = IMPLOT_AUTO
CIMGUI_API bool ImPlotColormapButtonEx(const char* label, ImVec2 size /* = ImVec2(0, 0) */, ImPlotColormap cmap /* = IMPLOT_AUTO */);

// When items in a plot sample their color from a colormap, the color is cached and does not change
// unless explicitly overriden. Therefore, if you change the colormap after the item has already been plotted,
// item colors will NOT update. If you need item colors to resample the new colormap, then use this
// function to bust the cached colors. If #plot_title_id is nullptr, then every item in EVERY existing plot
// will be cache busted. Otherwise only the plot specified by #plot_title_id will be busted. For the
// latter, this function must be called in the same ImGui ID scope that the plot is in. You should rarely if ever
// need this function, but it is available for applications that require runtime colormap swaps (e.g. Heatmaps demo).
IMPLOT_API
CIMGUI_API void ImPlotBustColorCache(void);                                         // Implied plot_title_id = nullptr
CIMGUI_API void ImPlotBustColorCacheEx(const char* plot_title_id /* = nullptr */);

//-----------------------------------------------------------------------------
// [SECTION] Input Mapping
//-----------------------------------------------------------------------------

// Provides access to input mapping structure for permanant modifications to controls for pan, select, etc.
IMPLOT_API
CIMGUI_API ImPlotInputMap* ImPlotGetInputMap(void);

// Default input mapping: pan = LMB drag, box select = RMB drag, fit = LMB double click, context menu = RMB click, zoom = scroll.
IMPLOT_API
CIMGUI_API void ImPlotMapInputDefault(void);                                   // Implied dst = nullptr
CIMGUI_API void ImPlotMapInputDefaultEx(ImPlotInputMap* dst /* = nullptr */);
// Reverse input mapping: pan = RMB drag, box select = LMB drag, fit = LMB double click, context menu = RMB click, zoom = scroll.
IMPLOT_API
CIMGUI_API void ImPlotMapInputReverse(void);                                   // Implied dst = nullptr
CIMGUI_API void ImPlotMapInputReverseEx(ImPlotInputMap* dst /* = nullptr */);

//-----------------------------------------------------------------------------
// [SECTION] Miscellaneous
//-----------------------------------------------------------------------------

// Render icons similar to those that appear in legends (nifty for data lists).
IMPLOT_API
CIMGUI_API void ImPlotItemIcon(ImVec4 col);
IMPLOT_API
CIMGUI_API void ImPlotItemIconImU32(ImU32 col);
IMPLOT_API
CIMGUI_API void ImPlotColormapIcon(ImPlotColormap cmap);

// Get the plot draw list for custom rendering to the current plot area. Call between Begin/EndPlot.
IMPLOT_API
CIMGUI_API ImDrawList* ImPlotGetPlotDrawList(void);
// Push clip rect for rendering to current plot area. The rect can be expanded or contracted by #expand pixels. Call between Begin/EndPlot.
IMPLOT_API
CIMGUI_API void        ImPlotPushPlotClipRect(void);                      // Implied expand = 0
CIMGUI_API void        ImPlotPushPlotClipRectEx(float expand /* = 0 */);
// Pop plot clip rect. Call between Begin/EndPlot.
IMPLOT_API
CIMGUI_API void        ImPlotPopPlotClipRect(void);

// Shows ImPlot style selector dropdown menu.
IMPLOT_API
CIMGUI_API bool ImPlotShowStyleSelector(const char* label);
// Shows ImPlot colormap selector dropdown menu.
IMPLOT_API
CIMGUI_API bool ImPlotShowColormapSelector(const char* label);
// Shows ImPlot input map selector dropdown menu.
IMPLOT_API
CIMGUI_API bool ImPlotShowInputMapSelector(const char* label);
// Shows ImPlot style editor block (not a window).
IMPLOT_API
CIMGUI_API void ImPlotShowStyleEditor(void);                                // Implied ref = nullptr
CIMGUI_API void ImPlotShowStyleEditorEx(ImPlotStyle* ref /* = nullptr */);
// Add basic help/info block for end users (not a window).
IMPLOT_API
CIMGUI_API void ImPlotShowUserGuide(void);
// Shows ImPlot metrics/debug information window.
IMPLOT_API
CIMGUI_API void ImPlotShowMetricsWindow(void);                              // Implied p_popen = nullptr
CIMGUI_API void ImPlotShowMetricsWindowEx(bool* p_popen /* = nullptr */);

//-----------------------------------------------------------------------------
// [SECTION] Demo
//-----------------------------------------------------------------------------

// Shows the ImPlot demo window (add implot_demo.cpp to your sources!)
IMPLOT_API
CIMGUI_API void ImPlotShowDemoWindow(void);                            // Implied p_open = nullptr
CIMGUI_API void ImPlotShowDemoWindowEx(bool* p_open /* = nullptr */);
#ifdef __cplusplus
} // End of extern "C" block
#endif
